<snippet>
  <content><![CDATA[
/* Abhishek Agrahari */
#include <bits/stdc++.h>
#include <array>
using namespace std;
using namespace chrono;
#define pb push_back
#define nl "\n"
#define all(x) x.begin(), x.end()
#define mp make_pair
#define B begin()
#define E end()
typedef long long ll;
typedef unsigned long long ull;
typedef long double lld;
#define F first
#define S second
#define v1 vector<ll>
#define int ll
#define v2(arr2d,rows,columns) vector<vector<ll>> arr2d(rows,vector<ll>(columns))
#define nline cout << "\n"
#define sp " "
#ifdef Abhishek
#define deb(x) cerr << #x<<" "; _print(x); cerr << endl;
#define deb0(a) cerr<< #a <<"="<< a << " ";
#define deb1(a) cerr<< #a <<"="<< a << "\n";
#define deb2(a, b) cerr << #a << "="<< a << " " << #b << "=" << b << "\n"
#define deb3(a, b, c) cerr << #a << "=" << a << " " << #b << "=" << b << " " << #c << "=" << c << "\n"
#define deb4(a, b, c, d) cerr << #a << "=" << a << " " << #b << "=" << b << " " << #c << "=" << c << " " << #d << "=" << d << "\n"
#define deba2(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cerr<<dp[i][j]<<" ";cerr<<"\n";}
#else
#define deb(x);
#define deb0(a);
#define deb1(a);
#define deb2(a, b);
#define deb3(a, b, c);
#define deb4(a, b, c, d);
#define deba2(dp,n,m)
#endif
#define inf 1000000000000000000
const double delta = 0.0000000001;
const double pi = 3.1415926535;
ll MOD = 1000000007;
#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
// 1) x & (x - 1):sets the last one bit of x to zero
// power of two exactly when x & (x âˆ’ 1) = 0.
// 2)x & -x:sets all the one bits to zero, except last one bit
// 3)x | (x - 1):inverts all the bits after the last one bit
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << "{"; _print(p.F); cerr << ","; _print(p.S); cerr << "}";}
template <class T> void _print(vector <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(set <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T> void _print(multiset <T> v) {cerr << "[ "; for (T i : v) {_print(i); cerr << " ";} cerr << "]";}
template <class T, class V> void _print(map <T, V> v) {cerr << "[ "; for (auto i : v) {_print(i); cerr << " ";} cerr << "]";}
//*****************************************
ll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}
ll gcd(ll a, ll b) { if (b == 0) return a; return gcd(b, a % b);}
ll lcm(ll a, ll b) { ll x = gcd(a, b); ll ans = (a * b) / x; return ans; }
void swap(ll &x, ll &y) {ll temp = x; x = y; y = temp;}
ll modInverse(ll n, ll t) { return expo(n, t - 2, t);}
void factors(ll n) {v1 factor; for (ll i = 1; i * i <= n; i++) if (n % i == 0) { if (n / i == i) factor.pb(i); else {factor.pb(i); factor.pb(n / i);}}}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ull nCrModPFermat(ull n, ull r) {if (n < r) return 0; if (r == 0) return 1; vector<ull> fac(n + 1); fac[0] = 1; for (ll i = 1; i <= n; i++) fac[i] = (fac[i - 1] * i) % MOD; return (fac[n] * modInverse(fac[r], MOD) % MOD * modInverse(fac[n - r], MOD) % MOD) % MOD;}
//**********************************************************CODE STARTS **************************************************************

void build(int *arr, int *segtree, int s, int e, int tidx) {
	//base case
	if (s == e) {
		segtree[tidx] = arr[s];
		return;
	}
	int mid = (s + e) / 2;
	build(arr, segtree, s, mid, 2 * tidx);
	build(arr, segtree, mid + 1, e, 2 * tidx + 1);

	//self work
	segtree[tidx] = segtree[2 * tidx] + segtree[2 * tidx + 1];
}
void update(int *arr, int *tree, int s, int e, int tidx, int idx, int val) {
	if (s == e) {
		tree[tidx] = val;
		arr[idx] = val;
		return;
	}
	int mid = (s + e) / 2;
	if (idx > mid) {
		update(arr, tree, mid + 1, e, 2 * tidx + 1, idx, val);
	}
	else {
		update(arr, tree, s, mid, 2 * tidx, idx, val);
	}
	tree[tidx] = tree[2 * tidx] + tree[2 * tidx + 1];
}

//s and e tells what node represent and left right is of query
int query(int *tree, int s, int e, int tidx, int left, int right) {
	if (s > right or e < left) {
		//completely outside
		return 0;
	}
	if (s >= left and e <= right) {
		return tree[tidx];
	}
	int mid = (s + e) / 2;
	int a1 = query(tree, s, mid, 2 * tidx, left, right);
	int a2 = query(tree, mid + 1, e, 2 * tidx + 1, left, right);
	return a1 + a2;
}

void solve()
{
	int n; cin >> n;
	int *arr = new int[n];
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	int *segtree = new int[4 * n];
	build(arr, segtree, 0, n - 1, 1);
	int q;
	cin >> q;
	while (q--) {
		int type;
		cin >> type;
		if (type == 1) {
			int l, r;
			cin >> l >> r;
			cout << query(segtree, 0, n - 1, 1, l, r) << nl;
		}
		else {
			int i, v;
			cin >> i >> v;
			update(arr, segtree, 0, n - 1, 1, i, v);
		}
	}
}


signed main() {
#ifdef Abhishek
	freopen("Error.txt", "w", stderr);
#endif
	fastio();
	solve();
	return 0;
}



]]></content>
  <tabTrigger>seg</tabTrigger>
  <description>Segment Tree</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
 <scope >source.c++</scope >
</snippet>